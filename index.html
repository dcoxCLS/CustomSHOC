<html>
	<head>
		<meta charset="utf-8" />
 <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no" />
		<title>SHOC Desktop</title>
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
			}
		</style>
		<!-- The esriConfig variable must be defined before adding the other esri libraries -->
<script>

	var esriConfig = {
		apiKey: "AAPTxy8BH1VEsoebNVZXo8HurAKZ1R9zZUhtYJKjIr1fz5pN7cpRVXEzuiVZBh-xkICT-UQOW6kP1H12ApWOassQNuDem-h62hwl6c-7Vjn2N-wa-DFTMRJYmjp5zC4Vwr8zKs2OAdvSBuGFlYF7LpexURzL9akLP_YG6WUTIuBTgkXyjm2cs4Uxh7cv1GL990cORv9tKWftlcQpt0gvXmnDNsOLs7ZqTr-L1A5qoLoPoBM.AT1_zrp36nE9",
	};

</script>
<!-- Load Calcite components from CDN -->
		<script type="module" src="https://js.arcgis.com/calcite-components/3.2.1/calcite.esm.js"></script>

		<!-- Load the ArcGIS Maps SDK for JavaScript from CDN -->
		<link rel="stylesheet" href="https://js.arcgis.com/4.33/esri/themes/light/main.css" />
		<script src="https://js.arcgis.com/4.33/"></script>

		<!-- Load Map components from CDN-->
		<script type="module" src="https://js.arcgis.com/4.33/map-components/"></script>
	</head>

	<body>
        <calcite-shell>
    <calcite-navigation slot="header">
        <calcite-navigation-logo slot="logo" heading="SHOC Desktop Version"></calcite-navigation-logo>
    </calcite-navigation>
	<div id="slider-container" style="padding: 0 10 0 10; margin: 0"><label style="padding: 0 ; margin: 0">Historic Map Opacity
        <calcite-slider style="padding: 0 ; margin: 0" value="100" id="sliderDiv" label-ticks max-label="100" min-label="0" ticks="100"></calcite-slider>
	</label></div>
<arcgis-map basemap="satellite" center= "-79.939, 32.785" zoom= "14">
	<arcgis-zoom position="top-left"></arcgis-zoom>
	<arcgis-home position="top-left"></arcgis-home>
	<arcgis-locate position="top-left" scale="500"></arcgis-locate>
      <arcgis-scale-bar
    position="bottom-left"
    bar-style="ruler"
    unit="imperial"
  ></arcgis-scale-bar>
	<arcgis-search position="top-right"></arcgis-search>
		<arcgis-placement position="top-right">
				<calcite-select id="sqlSelect">
					<calcite-option
						id="defaultOption"
						value="1=0"
						label="Choose a historic map"></calcite-option>
					<calcite-option
						value="mapyear = '1888'"
						label="Sanborn 1888"></calcite-option>
					<calcite-option
						value="mapyear = '1788'"
						label="Petrie 1788"></calcite-option>
				</calcite-select>
			</arcgis-placement>
</arcgis-map>
</calcite-shell>
Â <script type="module">
    const opacityInput = document.getElementById('sliderDiv');

			const FeatureLayer = await $arcgis.import("@arcgis/core/layers/FeatureLayer.js");
            const TileLayer = await $arcgis.import("@arcgis/core/layers/TileLayer.js");

			const viewElement = document.querySelector("arcgis-map");
			const selectFilter = document.querySelector("#sqlSelect");
			const defaultOption = document.querySelector("#defaultOption");
			let whereClause = defaultOption.value;
			const zoom = viewElement.zoom;

			viewElement.addEventListener("arcgisViewReadyChange", () => {

				//dynamically update dropdown
				//event listener for when the extent of the map changes
				viewElement.addEventListener("arcgisViewChange", (event) => {
					queryCount(viewElement.extent);
				});

				function queryCount(extent) {
					selectFilter.innerHTML = '<calcite-option id="defaultOption" value="1=0" label="Choose a historic map"></calcite-option>';
					const parcelQuery = {
						spatialRelationship: "intersects", // Relationship operation to apply
						geometry: extent, // Restricted to visible extent of the map
						outFields: ["title", "mapyear", "service_url"], // Attributes to return
						returnGeometry: true,
					};

					parcelLayer
						.queryFeatures(parcelQuery)
						.then((results) => {
							console.log("Feature count: " + results.features.length);

							// 1. Extract and sort features by mapyear
							const sortedFeatures = results.features
							.filter((feature) => feature.attributes.mapyear) // Ensure mapyear exists
							.sort((a, b) => a.attributes.mapyear - b.attributes.mapyear);

							// 2. Track seen years to avoid duplicates
							const seenYears = new Set();

							// 3. Create and append sorted options
							sortedFeatures.forEach((feature) => {
							const year = feature.attributes.mapyear;
							const title = feature.attributes.title;

							if (seenYears.has(year)) return;
							seenYears.add(year);

							const option = document.createElement("calcite-option");
							option.setAttribute("label", `${title} ${year}`);
							option.setAttribute("value", `mapyear = '${year}'`);
							selectFilter.appendChild(option);
							});



				});
			};
                
				//pulls up historic map
				// Event listener - after dropdown option selected
				selectFilter.addEventListener("calciteSelectChange", (event) => {
					whereClause = event.target.value;

					queryFeatureLayer(viewElement.extent);

				});

				// Get query layer and set up query
				const parcelLayer = new FeatureLayer({
					url: "https://portal1-geo.sabu.mtu.edu/server/rest/services/Hosted/map_index/FeatureServer/0",
				});

				function queryFeatureLayer(extent) {
                    viewElement.map.layers.removeAll();
					const parcelQuery = {
						where: whereClause, // Set by select element
						spatialRelationship: "intersects", // Relationship operation to apply
						geometry: extent, // Restricted to visible extent of the map
						outFields: ["title", "mapyear", "service_url"], // Attributes to return
						returnGeometry: true,
					};

					parcelLayer
						.queryFeatures(parcelQuery)
						.then((results) => {

							console.log("Feature count: " + results.features.length);

							displayResults(results);

						})
						.catch((error) => {
							console.log(error.error);
						});

				}
let tileLayer; // Declare this BEFORE displayResults is defined

                function displayResults(results) {
                const service_url = results.features[0]?.attributes?.service_url;

                if (!service_url) {
                    console.error("No service_url found in feature attributes.");
                    return;
                }

                // Remove previous tile layer if it exists
                if (tileLayer) {
                    viewElement.map.remove(tileLayer);
                }

                const initialOpacity = parseFloat(opacityInput.value) / 100;

                tileLayer = new TileLayer({
                    url: service_url,
                    opacity: initialOpacity,
                    });

                viewElement.map.add(tileLayer);

					const symbol = {
						type: "simple-fill",
						color: [20, 130, 200, 0],
						outline: {
							color: [20, 130, 200, 0],
							width: 0.5,
						},
					};

                    //popup
					const popupTemplate = {
						title: "{title} {mapyear}",
						content:
							"Maker: {title} <br> Year: {mapyear} <br> <a href={service_url}>View Service URL</a>",
					}      

					// Assign styles and popup to features
					results.features.map((feature) => {
						feature.symbol = symbol;
						feature.popupTemplate = popupTemplate;
						return feature;
					});


					// Clear display
					viewElement.closePopup();
					viewElement.graphics.removeAll();
					// Add features to graphics layer
					viewElement.graphics.addMany(results.features);
				}
                opacityInput.addEventListener('mouseup', function() {
    if (this.value > 0) {
        console.log("Range Slider has value of " + this.value);
        if (tileLayer) {
        tileLayer.opacity = parseFloat(this.value) / 100;
        }
    } else{
        console.log("Range Slider has value of " + this.value);
    }
});
});


                    </script>
	</body>

</html>
